#!/usr/bin/env python3
"""
eyes gets your IP's lat/lng and saves a mapbox wallpaper.png

 - needs a mapbox api key in env as MAPBOX_KEY
 - wallpapering uses https://github.com/derf/feh
 - pip install requests geocoder numpy Pillow

Usage:
    eyes /tmp/thing.png
    eyes --wallpaper
"""

import argparse
from PIL import Image, ImageFilter, ImageDraw, ImageFont, ImageChops
from io import BytesIO
import requests
import os
import datetime
import geocoder
import numpy as np
# import math
# import sys
import random
import subprocess
from functools import reduce
import cv2
# from wand.image import Image as WandImage

# from wand.image import Image
# from wand.drawing import Drawing
# from wand.color import Color

API_KEY = os.environ.get("MAPBOX_KEY")


def get_public_ip():
    return requests.get("https://ident.me").text


def get_location(ip):
    g = geocoder.ip(ip)
    return g.latlng


def get_map_image(lat, lng, zoom, mapbox_size):
    URL = f"https://api.mapbox.com/styles/v1/mapbox/satellite-v9/static/{lng},{lat},{zoom}/{mapbox_size[0]}x{mapbox_size[1]}?access_token={API_KEY}"

    response = requests.get(URL)

    if response.status_code == 200:
        try:
            return Image.open(BytesIO(response.content))
        except:
            print("Failed to identify the image file:")
            print(response.content)
    else:
        print(f"Request failed: {response.status_code}")


def add_text(img, lat, lng, x=30, y=50):
    font = ImageFont.truetype("/home/jtm/.fonts/FreeMono.ttf", 24)
    draw = ImageDraw.Draw(img)

    text_color = (255, 0, 0)
    outline_color = (255, 0, 0)

    text_lat = f"Lat: {lat}"
    text_lng = f"Lon: {lng}"

    # Draw the outlines for the text by drawing the text in the outline color at positions slightly
    # offset from the original position
    for dx, dy in [(-3, -3), (-3, 3), (3, -3), (3, 3)]:
        draw.text((x + dx, y + dy), text_lat, font=font, fill=(0, 0, 0))
        draw.text((x + dx, y + 50 + dy), text_lng, font=font, fill=(0, 0, 0))

    for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:
        draw.text((x + dx, y + dy), text_lat, font=font, fill=outline_color)
        draw.text((x + dx, y + 50 + dy), text_lng, font=font, fill=outline_color)

    # Draw the text
    draw.text((x, y), text_lat, fill=text_color, font=font)
    draw.text((x, y + 50), text_lng, fill=text_color, font=font)


def randomize_axis(coords):
    lat, lng = coords

    if random.choice([True, False]):
        lat += random.uniform(-10, 10)
    else:
        lng += random.uniform(-10, 10)

    lat = max(min(lat, 90), -90)
    lng = max(min(lng, 180), -180)

    return round(lat, 4), round(lng, 4)


def resize_image(img, save_size=(1280, 800)):
    return img.resize(save_size, Image.Resampling.LANCZOS)


def convert_to_monochrome(img):
    return img.convert("L").convert("RGB")


def add_noise(image, location=0.0, scale=35):
    arr = np.asarray(image)
    noise = np.random.normal(location, scale, arr.shape)
    noisy_arr = arr + noise
    noisy_arr = np.clip(noisy_arr, 0, 255)
    return Image.fromarray(np.uint8(noisy_arr))


def glitch_effect(img):
    img = img.convert("RGBA")
    # Extract R,G,B channels
    r, g, b, a = img.split()
    # Shift RGB channels
    r = ImageChops.offset(r, 5)
    g = ImageChops.offset(g, -5)
    # Combine shifted channels
    img = Image.merge("RGBA", (r, g, b, a))
    return img


def hellzone(img):
    red = Image.new("RGB", img.size, (255, 0, 0))
    img = Image.blend(img, red, 0.5)
    return img


def watercolor_effect(img):
    import tempfile
    import subprocess
    from PIL import Image

    # Create temporary files for input and output
    with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_in, \
         tempfile.NamedTemporaryFile(suffix='.png', delete=False) as temp_out:

        # Save input image to temporary file
        img.save(temp_in.name)

        # Construct and run the watercolor command
        command = f"watercolor -s 5 -e 5 -m 50 -c 5 {temp_in.name} {temp_out.name}"
        try:
            subprocess.run(command, check=True, shell=True)
        except subprocess.CalledProcessError:
            print(f'"{command}" failed.')
            return img  # Return original image if command fails

        # Open and return the processed image
        return Image.open(temp_out.name)


def idk_effect(img):
    img = img.filter(ImageFilter.MedianFilter(size=1))
    img = img.filter(ImageFilter.ModeFilter(size=1))
    return img


def set_wallpaper(image_path):
    backgrounds_file = os.path.expanduser('~/.feh-backgrounds')

    # Comment out the last line if the file exists
    if os.path.isfile(backgrounds_file):
        with open(backgrounds_file, 'r+') as file:
            lines = file.readlines()
            if lines:
                lines[-1] = f"# {lines[-1]}"  # Comment out the last line
            file.seek(0)
            file.writelines(lines)

    command = f"feh --bg-scale {image_path}"
    os.system(command)

    # Append the new wallpaper command
    with open(backgrounds_file, 'a') as file:
        file.write(f"{command}\n")


def noisy_blob(img, num_circles=100, min_radius=20, max_radius=80, dilate_iter=3, blur_size=5):
    img_arr = np.asarray(img)
    mono_arr = np.asarray(convert_to_monochrome(img))

    mask = np.zeros((img.height, img.width), dtype=np.uint8)
    for _ in range(num_circles):
        x, y = np.random.randint(0, img.width), np.random.randint(0, img.height)
        radius = np.random.randint(min_radius, max_radius)
        cv2.circle(mask, (x, y), radius, (255, 255, 255), thickness=-1)

    # Create kernel for dilation
    kernel = np.ones((5, 5), np.uint8)

    # Dilate and blur the mask
    dilated_mask = cv2.dilate(mask, kernel, iterations=dilate_iter)
    blurred_mask = cv2.GaussianBlur(dilated_mask, (blur_size, blur_size), 0)

    # Apply mask after creating all blobs
    masked_img_arr = np.where(blurred_mask[..., None], img_arr, mono_arr)

    return Image.fromarray(masked_img_arr)


def noisy_dots(img, num_circles=10, min_radius=20, max_radius=80):
    img_arr = np.asarray(img)
    mono_arr = np.asarray(convert_to_monochrome(img))

    mask = np.zeros((img.height, img.width), dtype=np.uint8)
    for _ in range(num_circles):
        x, y = np.random.randint(0, img.width), np.random.randint(0, img.height)
        radius = np.random.randint(min_radius, max_radius)
        cv2.circle(mask, (x, y), radius, (255, 255, 255), thickness=-1)

    # Apply mask after creating all circles
    masked_img_arr = np.where(mask[..., None], img_arr, mono_arr)

    return Image.fromarray(masked_img_arr)


def crop_bottom(img, pixels_to_crop):
    width, height = img.size
    return img.crop((0, 0, width, height - pixels_to_crop))


def archive(img, path):
    # Define the backup directory
    backup_dir = os.path.expanduser("~/.cache/eyes/")

    # Check if backup directory exists, if not create it
    if not os.path.isdir(backup_dir):
        os.makedirs(backup_dir)

    # Extract the basename and extension from the original path
    basename = os.path.basename(path)
    name, ext = os.path.splitext(basename)

    # Generate a new filename based on the current date and original filename
    date_str = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
    new_filename = f"{date_str}-{name}{ext}"

    # Define the full backup path
    backup_path = os.path.join(backup_dir, new_filename)

    print(f"Archiving to {backup_path}")

    # Save the image to the backup path
    img.save(backup_path)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("path", nargs="?", default="wallpaper.png", help="Path to save the image")
    parser.add_argument("-w", "--wallpaper", action="store_true", help="Save as wallpaper with feh")
    parser.add_argument("-d", "--dry", action="store_true", help="Print the values and nothing more")
    args = parser.parse_args()

    ip = get_public_ip()
    lat, lng = get_location(ip)
    r_lat, r_lng = randomize_axis((lat, lng))

    if args.dry:
        print(ip)
        print((lat, lng))
        print((r_lat, r_lng))
        exit()

    # Config
    zoom = 15
    mapbox_size = (1280, 850)
    save_size = (1280, 850)

    # Initial image
    img = get_map_image(r_lat, r_lng, zoom, mapbox_size)

    # these are transformations applied to a wallpaper of a satellite image
    transformations = [
        # [
        #     lambda img: resize_image(img, save_size),
        #     convert_to_monochrome,
        #     lambda img: add_noise(img, scale=20),
        # ],
        [
            lambda img: resize_image(img, save_size),
            lambda img: crop_bottom(img, 50),  # Add this line
            convert_to_monochrome,
            noisy_blob,
            # watercolor_effect,
            lambda img: add_noise(img, scale=10),
        ],
        # [
        #     lambda img: resize_image(img, save_size),
        #     lambda img: add_noise(img, scale=20),
        # ],
        # [lambda img: resize_image(img, save_size), lambda img: crop_bottom(img, 50), glitch_effect],
        # [lambda img: resize_image(img, save_size), hellzone],
        # [
        #     lambda img: resize_image(img, save_size),
        #     lambda img: watercolor_effect(img),
        # ],
        # [
        #     lambda img: resize_image(img, save_size),
        # ],
    ]

    final_img = reduce(lambda img, f: f(img), random.choice(transformations), img)

    # add_text(noisy_img, lat, lng, x=30, y=50)
    # add_text(noisy_img, r_lat, r_lng, x=30, y=200)

    archive(final_img, args.path)
    print(f"Saved to {args.path}")
    final_img.save(args.path)

    if args.wallpaper:
        set_wallpaper(args.path)
